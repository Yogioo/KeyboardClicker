ultimate-grid-system/
│
├── src/                      # 源代码目录
│   ├── core/                 # 核心逻辑模块
│   │   ├── __init__.py
│   │   ├── state_manager.py  # 全局状态机
│   │   ├── grid_logic.py     # 网格数学计算逻辑
│   │   └── input_processor.py# 用户输入处理与指令解析
│   │
│   ├── ui/                   # 用户界面模块
│   │   ├── __init__.py
│   │   └── grid_overlay.py   # 网格和路径的可视化叠加层
│   │
│   ├── platform/             # 平台相关模块
│   │   ├── __init__.py
│   │   ├── hotkey_manager.py # 全局热键监听 (Windows)
│   │   └── mouse_controller.py # 鼠标动作控制器 (Windows)
│   │
│   └── main.py               # 应用程序主入口
│
├── tests/                    # 测试代码目录
│   ├── core/
│   │   ├── __init__.py
│   │   ├── test_state_manager.py
│   │   ├── test_grid_logic.py
│   │   └── test_input_processor.py
│   │
│   ├── ui/
│   │   ├── __init__.py
│   │   └── test_grid_overlay.py
│   │
│   └── platform/
│       ├── __init__.py
│       ├── test_hotkey_manager.py
│       └── test_mouse_controller.py
│
├── requirements.txt          # 项目依赖
└── README.md                 # 项目说明```

---

### **第二步：模块化开发计划 (按开发顺序)**

我们将按照从底层逻辑到上层界面的顺序进行开发，确保每个新模块都建立在已经过测试的稳定基础之上。

#### **模块一：网格数学计算 (`src/core/grid_logic.py`)**

这是整个系统的数学核心，它不关心界面或输入，只负责计算。

*   **功能职责**:
    1.  获取主屏幕或所有屏幕的尺寸和位置。
    2.  维护一个当前的矩形区域（初始为全屏）。
    3.  提供一个核心函数 `calculate_next_rect(current_rect, key)`，根据当前区域和按键（如 'Q', 'W', 'E'）返回下一级的子区域坐标。
    4.  提供一个 `reset()` 方法，将当前区域重置为全屏。
    5.  计算给定区域的中心点坐标，用于最终的鼠标点击。

*   **对应的测试类 (`tests/core/test_grid_logic.py`)**:
    *   `test_initial_rect_is_fullscreen()`: 测试初始区域是否正确获取为屏幕大小。
    *   `test_calculate_next_rect_qwe()`: 模拟在一个 1920x1080 的屏幕上，输入 'E'（右上角）后，返回的矩形坐标是否是 `(1280, 0, 640, 360)`。对所有九个按键进行测试。
    *   `test_recursive_calculation()`: 模拟连续输入 `EDC`，验证最终计算出的区域坐标是否符合预期。
    *   `test_get_center_point()`: 测试能否正确计算任意矩形的中心点。
    *   `test_reset_function()`: 测试调用 `reset()` 后，当前区域是否能恢复到全屏。

---

#### **模块二：鼠标动作控制器 (`src/platform/mouse_controller.py`)**

这个模块封装了所有与操作系统鼠标交互的底层操作，使其与核心逻辑解耦。

*   **功能职责**:
    1.  `move_to(x, y)`: 移动鼠标到指定坐标。
    2.  `left_click(x, y)`: 移动并执行左键单击。
    3.  `right_click(x, y)`: 移动并执行右键单击。
    4.  `double_click(x, y)`: 移动并执行双击。
    5.  `press_left_button(x, y)`: 移动并按下左键（用于拖拽起点）。
    6.  `release_left_button(x, y)`: 移动并释放左键（用于拖拽终点）。
    *   *推荐使用 `pynput` 库来实现这些功能。*

*   **对应的测试类 (`tests/platform/test_mouse_controller.py`)**:
    *   由于直接测试会真实地移动鼠标，影响开发，所以我们采用“模拟（Mocking）”的方式。
    *   `test_left_click_calls_correct_functions()`: 模拟 `pynput` 库，验证调用 `left_click(100, 200)` 时，是否正确地调用了模拟库的 `position` 设置和 `press`/`release` 方法。
    *   对 `right_click`, `double_click`, `press_left_button` 等所有公共方法都编写类似的模拟测试。

---

#### **模块三：用户输入处理器 (`src/core/input_processor.py`)**

这是指令系统的大脑，负责解释用户的按键序列。

*   **功能职责**:
    1.  接收按键事件。
    2.  维护一个当前的输入路径字符串（如 `"EDC"`）。
    3.  解析路径和指令后缀。例如，当接收到 'R' 键时，识别出之前的路径和 "右键" 指令。
    4.  处理拖拽逻辑：接收到 'G' 后，进入“等待拖拽终点”的状态。
    5.  在没有指令后缀的情况下，将最后一个路径按键识别为默认的“左键单击”指令。
    6.  当解析出完整指令后，对外发出信号（例如，PyQt的signal），包含动作类型（如 `LEFT_CLICK`）和目标路径。
    7.  提供清空/重置当前输入的方法。

*   **对应的测试类 (`tests/core/test_input_processor.py`)**:
    *   `test_path_building()`: 模拟输入 'E', 'D', 'C'，验证内部路径字符串是否为 `"EDC"`。
    *   `test_default_left_click_action()`: 模拟输入 'C'，验证它是否能正确解析出 `"C"` 路径和“左键单击”指令。
    *   `test_command_suffix_parsing()`: 模拟输入 `EDCR`，验证解析结果为路径 `"EDC"` 和“右键单击”指令。对 'D', 'H' 等指令进行同样测试。
    *   `test_drag_and_drop_flow()`:
        *   模拟输入 `QAZG`，验证其状态变为“拖拽中”并正确解析出起点路径。
        *   接着模拟输入 `EDCG`，验证其能正确解析出终点路径并发出“执行拖拽”的指令。

---

#### **模块四：可视化叠加层 (`src/ui/grid_overlay.py`)**

用户能看到的一切。使用 PyQt6 创建一个全屏、透明、无边框的顶层窗口。

*   **功能职责**:
    1.  根据 `grid_logic` 计算出的当前区域，绘制半透明的九宫格分割线。
    2.  在屏幕一角，根据 `input_processor` 传入的当前路径，显示路径指示器（如 `E -> D -> C`）。
    3.  在拖拽操作中，根据指令标记视觉“锚点”，并实时绘制从锚点到当前鼠标（或网格中心）的引导线/选框。
    4.  提供 `show()` 和 `hide()` 方法。
    5.  捕获键盘输入事件并传递给 `input_processor` 进行处理。

*   **对应的测试类 (`tests/ui/test_grid_overlay.py`)**:
    *   UI 测试的重点是测试其状态和数据，而非像素级的渲染结果。
    *   `test_update_grid_lines()`: 调用一个方法 `update_grid_data(rect)`，然后检查窗口内部存储的用于绘制的线条坐标是否被正确更新。
    *   `test_update_path_indicator()`: 调用 `update_path_text("E -> D")`，验证界面上对应的标签控件文本是否被正确设置。
    *   `test_drag_visuals_logic()`: 测试调用 `start_drag_mode(anchor_point)` 后，是否正确设置了内部的拖拽可视化状态。

---

#### **模块五：全局状态与热键管理器**

这两个紧密相关，可以合并或分为两个小模块。

*   **`src/platform/hotkey_manager.py`**:
    *   **功能职责**: 在后台运行，监听系统范围的组合键（如 `Alt+G`）。当热键被按下时，通知主程序切换激活状态。
    *   **测试类 (`tests/platform/test_hotkey_manager.py`)**: 使用模拟方式测试热键按下后，预设的回调函数是否被正确调用。

*   **`src/core/state_manager.py`**:
    *   **功能职责**: 管理程序的全局状态，如 `INACTIVE` (隐藏), `SELECTING` (激活选择中), `DRAGGING` (拖拽中)。确保所有模块的行为都基于当前状态，避免逻辑混乱。
    *   **测试类 (`tests/core/test_state_manager.py`)**: 测试状态转换的合法性，例如 `INACTIVE` -> `SELECTING` 是合法的，但 `INACTIVE` -> `DRAGGING` 是非法的。

---

#### **模块六：主程序入口 (`src/main.py`)**

这是所有模块的“胶水”层，负责组装和连接。

*   **功能职责**:
    1.  创建 PyQt 应用实例。
    2.  实例化所有模块：`GridLogic`, `MouseController`, `InputProcessor`, `GridOverlay`, `HotkeyManager` 等。
    3.  **核心任务：信号与槽的连接**。
        *   `HotkeyManager` 的 `activated` 信号连接到 `GridOverlay` 的 `show()` 和 `InputProcessor` 的 `start()`。
        *   `InputProcessor` 发出的指令信号，连接到一个处理函数。该函数会：
            *   调用 `GridLogic` 计算最终坐标。
            *   调用 `MouseController` 执行相应的鼠标动作。
            *   最后调用 `GridOverlay` 的 `hide()` 和 `InputProcessor` 的 `reset()` 来结束一次操作。
        *   `InputProcessor` 的路径更新信号连接到 `GridOverlay` 的 `update_path_indicator()` 和 `update_grid_lines()`。
    4.  启动 PyQt 事件循环。

*   **测试**: 这个模块主要是集成，单元测试较少。它的正确性由之前所有模块的测试和最终的手动 E2E（端到端）测试来保证。

### **第三步：后期拓展**

在完成以上核心功能并全部测试通过后，再进行拓展。

*   **支持 4x3 网格**:
    1.  修改 `grid_logic.py` 中的 `calculate_next_rect`，使其能处理 4x3 的分割。
    2.  修改 `ui/grid_overlay.py` 的绘制逻辑，画出 4x3 的线条。
    3.  修改 `input_processor.py` 接受的合法按键集合。
    4.  可以将其做成一个可配置的选项。

这个开发计划将引导您构建一个结构清晰、易于维护和测试的高质量应用程序。祝您开发顺利！